'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var urijs = _interopDefault(require('urijs'));
var reduxApiMiddleware = require('redux-api-middleware');
var queryString = require('query-string');
var _ = _interopDefault(require('lodash'));
var FormData = _interopDefault(require('form-data'));

var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// ['REQUEST', 'SUCESS', 'FAILURE'];
// mapById(['entity']);
// defaultGuessing by name;
var BASIC = ['REQUEST', 'SUCCESS', 'FAILURE'];
function entity(name) {
  return ['REQUEST', {
    type: 'SUCCESS',
    meta: { data: name },
    payload: function payload(action, state, res) {
      return res.json();
    }
  }, 'FAILURE'];
}
function formData(dataMap, contentType) {
  if (!dataMap) return null;
  if (contentType === 'multipart/form-data') {
    var _formData = new FormData();

    Object.keys(dataMap).forEach(function (key) {
      return _formData.append(key, dataMap[key]);
    });

    return _formData;
  } else if (contentType === 'application/x-www-form-urlencoded') {
    return queryString.stringify(dataMap);
  } else if (contentType === 'application/json') {
    return JSON.stringify(dataMap);
  } else {
    throw new Error('unknown contentType for ' + contentType);
  }
}
function getConventionalName(pathName, method) {
  return method + pathName.replace(/\{.*\}/g, '').replace(/\/(.)/g, function ($1) {
    return $1.toUpperCase();
  }).replace(/\//g, '');
}
function processType(types, pathName, method) {
  var originalTypes = _.cloneDeep(types);
  var processedTypes = [];

  originalTypes = originalTypes.map(function (originalType) {
    if (typeof originalType == 'string') {
      return { type: originalType };
    } else {
      return originalType;
    }
  });
  console.log('types', types);
  processedTypes[0] = _extends$1({}, originalTypes[0], {
    meta: _extends$1({
      path: pathName,
      name: getConventionalName(pathName, method),
      method: method
    }, originalTypes[0].meta)
  });
  processedTypes[1] = _extends$1({}, originalTypes[1], {
    meta: _extends$1({
      path: pathName,
      name: getConventionalName(pathName, method),
      method: method
    }, originalTypes[1].meta)
  });
  processedTypes[2] = _extends$1({}, originalTypes[2], {
    meta: _extends$1({
      path: pathName,
      name: getConventionalName(pathName, method),
      method: method
    }, originalTypes[2].meta)
  });

  return processedTypes;
}
function subsituteUrl(url, substitues) {
  var finalUrl = url;

  Object.keys(substitues).forEach(function (key, index) {
    finalUrl = finalUrl.replace('{' + key + '}', substitues[key]);
  });
  return finalUrl;
}

var Helper = Object.freeze({
	BASIC: BASIC,
	entity: entity,
	formData: formData,
	processType: processType,
	subsituteUrl: subsituteUrl
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function setProtocol(protocol) {
  return {
    type: 'API:SET_PROTOCOL',
    payload: protocol
  };
}

function setSwagger(swagger) {
  return {
    type: 'API:SET_SWAGGER',
    payload: swagger
  };
}
function setHeaders(headers) {
  return {
    type: 'API:SET_BASE_HEADERS',
    payload: {
      headers: headers
    }
  };
}
function request(pathName, _ref, types) {
  var _this = this;

  var method = _ref.method,
      data = _ref.data,
      subst = _ref.subst;

  return function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(dispatch, getState) {
      var pathEntity, entityPath, realPath, headers, body, result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              pathEntity = _.get(getState().api.paths, pathName);
              entityPath = pathName;

              if (subst) {
                entityPath = subsituteUrl(pathName, subst);
              }
              realPath = entityPath;

              // //TODO Header should be create by Header constructor instead of plain object

              headers = _extends({}, getState().api.headers, pathEntity.headers);
              body = void 0;

              if (method == 'get' && data) {
                realPath = realPath + '?' + queryString.stringify(data);
              } else {
                body = formData(data, headers['Content-Type']);
              }

              if (headers['Content-Type'] === 'multipart/form-data') {
                delete headers['Content-Type'];
                delete headers['content-type'];
              }
              //
              result = {
                endpoint: getState().api.protocol + '://' + getState().api.host + getState().api.basePath + realPath,
                method: method,

                headers: headers,
                body: body,
                types: processType(types, pathName, method)
              };
              _context.next = 11;
              return dispatch(_defineProperty({}, reduxApiMiddleware.CALL_API, result));

            case 11:
              return _context.abrupt('return', _context.sent);

            case 12:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
}

var Action = Object.freeze({
	setProtocol: setProtocol,
	setSwagger: setSwagger,
	setHeaders: setHeaders,
	request: request
});

var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function api() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { protocol: 'http', contentType: '', headers: {} };
  var action = arguments[1];

  switch (action.type) {
    case 'API:SET_BASE_HEADERS':
      return _extends$2({}, state, { headers: action.payload.headers });
    case 'API:SET_SWAGGER':
      return _extends$2({}, state, action.payload);
    case 'API:SET_PROTOCOL':
      return _extends$2({}, state, { protocol: action.payload });
  }
  return state;
}

var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function domain() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  var idsRegexResult = /^(.+)S_BY_ID$/.exec(_.get(action, 'meta.data'));

  switch (true) {
    case idsRegexResult != null:
      var relatedIdsName = _.camelCase(idsRegexResult[1]) + 'sById';
      var newObjectWithIds = {};
      newObjectWithIds[relatedIdsName] = action.payload;

      return _extends$3({}, state, newObjectWithIds);
  }
  return state;
}

var _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function network() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  switch (true) {
    case action.type == 'SUCCESS':
      console.log('action', action);
      return _extends$4({}, state, _defineProperty$1({}, action.meta.name, 'SUCCESS'));

    case action.type == 'FAILURE':
      return _extends$4({}, state, _defineProperty$1({}, action.meta.name, 'FAILURE'));

    case action.type == 'REQUEST':
      return _extends$4({}, state, _defineProperty$1({}, action.meta.name, 'REQUEST'));
  }
  return state;
}

var Reducer = {
  domain: domain,
  network: network,
  api: api
};

var lib = {
  Action: Action,
  Helper: Helper,
  Reducer: Reducer
};

module.exports = lib;
//# sourceMappingURL=index.min.js.map
