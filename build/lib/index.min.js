'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var urijs = _interopDefault(require('urijs'));
var reduxApiMiddleware = require('redux-api-middleware');
var queryString = require('query-string');
var _ = _interopDefault(require('lodash'));
var FormData = _interopDefault(require('form-data'));

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};









var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

// ['REQUEST', 'SUCESS', 'FAILURE'];
// mapById(['entity']);
// defaultGuessing by name;
var BASIC = ['REQUEST', 'SUCCESS', 'FAILURE'];
function entity(name) {
  return ['REQUEST', {
    type: 'SUCCESS',
    meta: { data: name },
    payload: function payload(action, state, res) {
      return res.json();
    }
  }, 'FAILURE'];
}
function formData(dataMap, contentType) {
  if (!dataMap) return null;
  if (contentType === 'multipart/form-data') {
    var _formData = new FormData();

    Object.keys(dataMap).forEach(function (key) {
      return _formData.append(key, dataMap[key]);
    });

    return _formData;
  } else if (contentType === 'application/x-www-form-urlencoded') {
    return queryString.stringify(dataMap);
  } else if (contentType === 'application/json') {
    return JSON.stringify(dataMap);
  } else {
    throw new Error('unknown contentType');
  }
}
function processType(types, pathName) {
  var originalTypes = _.cloneDeep(types);
  var processedTypes = [];

  originalTypes = originalTypes.map(function (originalType) {
    if (typeof originalType == 'string') {
      return { type: originalType };
    } else {
      return originalType;
    }
  });

  processedTypes[0] = _extends({}, originalTypes[0], {
    meta: _extends({
      source: pathName
    }, originalTypes[0].meta)
  });
  processedTypes[1] = _extends({}, originalTypes[1], {
    meta: _extends({
      source: pathName
    }, originalTypes[1].meta)
  });
  processedTypes[2] = _extends({}, originalTypes[2], {
    meta: _extends({
      source: pathName
    }, originalTypes[2].meta)
  });

  return processedTypes;
}
function subsituteUrl(url, substitues) {
  var finalUrl = url;

  Object.keys(substitues).forEach(function (key, index) {
    finalUrl = finalUrl.replace('{' + key + '}', substitues[key]);
  });
  return finalUrl;
}



var Helper = Object.freeze({
	BASIC: BASIC,
	entity: entity,
	formData: formData,
	processType: processType,
	subsituteUrl: subsituteUrl
});

function setProtocol(protocol) {
  return {
    type: 'API:SET_PROTOCOL',
    payload: protocol
  };
}
function setSwagger(swagger) {
  return {
    type: 'API:SET_SWAGGER',
    payload: swagger
  };
}
function setHeaders(headers) {
  return {
    type: 'API:SET_BASE_HEADERS',
    payload: {
      headers: headers
    }
  };
}
function request(pathName, _ref, types) {
  var _this = this;

  var method = _ref.method,
      data = _ref.data,
      subst = _ref.subst;

  return function () {
    var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee(dispatch, getState) {
      var pathEntity, realPath, headers, body, result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              pathEntity = _.get(getState().api.paths, pathName);
              realPath = pathName;


              if (subst) {
                realPath = subsituteUrl(realPath, subst);
              }

              // //TODO Header should be create by Header constructor instead of plain object
              headers = _extends({}, getState().api.headers, pathEntity.headers);
              body = void 0;

              if (method == 'get') {
                realPath = realPath + '?' + queryString.stringify(data);
              } else {
                body = formData(data, headers['Content-Type']);
              }

              if (headers['Content-Type'] === 'multipart/form-data') {
                delete headers['Content-Type'];
                delete headers['content-type'];
              }
              //
              result = {
                endpoint: getState().api.protocol + '://' + getState().api.host + getState().api.basePath + realPath,
                method: method,

                headers: headers,
                body: body,
                types: processType(types, pathName)
              };
              _context.next = 10;
              return dispatch(defineProperty({}, reduxApiMiddleware.CALL_API, result));

            case 10:
              return _context.abrupt('return', _context.sent);

            case 11:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
}



var Action = Object.freeze({
	setProtocol: setProtocol,
	setSwagger: setSwagger,
	setHeaders: setHeaders,
	request: request
});

function api() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { protocol: 'http', headers: {} };
  var action = arguments[1];

  switch (action.type) {
    case 'API:SET_BASE_HEADERS':
      return _extends({}, state, { headers: action.payload.headers });
    case 'API:SET_SWAGGER':
      return _extends({}, state, action.payload);
    case 'API:SET_PROTOCOL':
      return _extends({}, state, { protocol: action.payload });
  }
  return state;
}

function domain() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  var idsRegexResult = /^(.+)S_BY_ID$/.exec(_.get(action, 'meta.data'));

  switch (true) {
    case idsRegexResult != null:
      var relatedIdsName = _.camelCase(idsRegexResult[1]) + 'sById';
      var newObjectWithIds = {};
      newObjectWithIds[relatedIdsName] = action.payload;

      return _extends({}, state, newObjectWithIds);
  }
  return state;
}

function network() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  switch (true) {
    case action.type == 'SUCCESS':
      return _extends({}, state, defineProperty({}, action.meta.source, 'SUCCESS'));

    case action.type == 'FAILURE':
      return _extends({}, state, defineProperty({}, action.meta.source, 'FAILURE'));

    case action.type == 'REQUEST':
      return _extends({}, state, defineProperty({}, action.meta.source, 'REQUEST'));
  }
  return state;
}

var reducers = {
  domain: domain,
  network: network,
  api: api
};

var Reducer = Object.freeze({
	default: reducers
});

var lib = {
  Action: Action,
  Helper: Helper,
  Reducer: Reducer
};

module.exports = lib;
//# sourceMappingURL=index.min.js.map
