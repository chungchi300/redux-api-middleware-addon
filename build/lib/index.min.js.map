{"version":3,"file":"index.min.js","sources":["../../src/common/helpers/api.js","../../src/common/actions/index.js","../../src/common/reducers/api.js","../../src/common/reducers/network.js","../../src/common/reducers/domain.js","../../src/common/reducers/index.js"],"sourcesContent":["import FormData from 'form-data';\nimport { stringify } from 'query-string';\n// ['REQUEST', 'SUCESS', 'FAILURE'];\nimport _ from 'lodash';\n// mapById(['entity']);\n// defaultGuessing by name;\nexport const BASIC = ['REQUEST', 'SUCCESS', 'FAILURE'];\nexport function entity(name) {\n  return [\n    'REQUEST',\n    {\n      type: 'SUCCESS',\n      meta: { data: name },\n      payload: (action, state, res) => {\n        return res.json();\n      },\n    },\n    'FAILURE',\n  ];\n}\nexport function formData(dataMap, contentType) {\n  if (!dataMap) return null;\n  if (contentType === 'multipart/form-data') {\n    let formData = new FormData();\n\n    Object.keys(dataMap).forEach(key => formData.append(key, dataMap[key]));\n\n    return formData;\n  } else if (contentType === 'application/x-www-form-urlencoded') {\n    return stringify(dataMap);\n  } else if (contentType === 'application/json') {\n    return JSON.stringify(dataMap);\n  } else {\n    throw new Error('unknown contentType');\n  }\n}\nexport function processType(types, pathName) {\n  let originalTypes = _.cloneDeep(types);\n  let processedTypes = [];\n\n  originalTypes = originalTypes.map(originalType => {\n    if (typeof originalType == 'string') {\n      return { type: originalType };\n    } else {\n      return originalType;\n    }\n  });\n\n  processedTypes[0] = {\n    ...originalTypes[0],\n    meta: {\n      source: pathName,\n      ...originalTypes[0].meta,\n    },\n  };\n  processedTypes[1] = {\n    ...originalTypes[1],\n    meta: {\n      source: pathName,\n      ...originalTypes[1].meta,\n    },\n  };\n  processedTypes[2] = {\n    ...originalTypes[2],\n    meta: {\n      source: pathName,\n      ...originalTypes[2].meta,\n    },\n  };\n\n  return processedTypes;\n}\nexport function subsituteUrl(url, substitues) {\n  let finalUrl = url;\n\n  Object.keys(substitues).forEach((key, index) => {\n    finalUrl = finalUrl.replace('{' + key + '}', substitues[key]);\n  });\n  return finalUrl;\n}\n","import URI from 'urijs';\nimport { CALL_API } from 'redux-api-middleware';\nimport { stringify } from 'query-string';\nimport _ from 'lodash';\nimport { subsituteUrl, formData, processType } from 'helpers/api';\nexport function setProtocol(protocol) {\n  return {\n    type: 'API:SET_PROTOCOL',\n    payload: protocol,\n  };\n}\nexport function setSwagger(swagger) {\n  return {\n    type: 'API:SET_SWAGGER',\n    payload: swagger,\n  };\n}\nexport function setHeaders(headers) {\n  return {\n    type: 'API:SET_BASE_HEADERS',\n    payload: {\n      headers: headers,\n    },\n  };\n}\nexport function request(pathName, { method, data, subst }, types) {\n  return async (dispatch, getState) => {\n    const pathEntity = _.get(getState().api.paths, pathName);\n    let realPath = pathName;\n\n    if (subst) {\n      realPath = subsituteUrl(realPath, subst);\n    }\n\n    // //TODO Header should be create by Header constructor instead of plain object\n    let headers = {\n      ...getState().api.headers,\n      ...pathEntity.headers,\n    };\n    let body;\n    if (method == 'get') {\n      realPath = realPath + '?' + stringify(data);\n    } else {\n      body = formData(data, headers['Content-Type']);\n    }\n\n    if (headers['Content-Type'] === 'multipart/form-data') {\n      delete headers['Content-Type'];\n      delete headers['content-type'];\n    }\n    //\n    const result = {\n      endpoint:\n        getState().api.protocol +\n        '://' +\n        getState().api.host +\n        getState().api.basePath +\n        realPath,\n      method: method,\n\n      headers: headers,\n      body: body,\n      types: processType(types, pathName),\n    };\n\n    return await dispatch({\n      [CALL_API]: result,\n    });\n  };\n}\n","export default function api(state = { protocol: 'http', headers: {} }, action) {\n  switch (action.type) {\n    case 'API:SET_BASE_HEADERS':\n      return { ...state, headers: action.payload.headers };\n    case 'API:SET_SWAGGER':\n      return { ...state, ...action.payload };\n    case 'API:SET_PROTOCOL':\n      return { ...state, protocol: action.payload };\n  }\n  return state;\n}\n","export default function network(state = {}, action) {\n  switch (true) {\n    case action.type == 'SUCCESS':\n      return { ...state, [action.meta.source]: 'SUCCESS' };\n\n    case action.type == 'FAILURE':\n      return { ...state, [action.meta.source]: 'FAILURE' };\n\n    case action.type == 'REQUEST':\n      return { ...state, [action.meta.source]: 'REQUEST' };\n  }\n  return state;\n}\n","import _ from 'lodash';\nexport default function domain(state = {}, action) {\n  let idsRegexResult = /^(.+)S_BY_ID$/.exec(_.get(action, 'meta.data'));\n\n  switch (true) {\n    case idsRegexResult != null:\n      let relatedIdsName = _.camelCase(idsRegexResult[1]) + 'sById';\n      let newObjectWithIds = {};\n      newObjectWithIds[relatedIdsName] = action.payload;\n\n      return { ...state, ...newObjectWithIds };\n  }\n  return state;\n}\n","import api from './api';\nimport network from './network';\nimport domain from './domain';\nconst rootReducer = function(state = {}, action) {\n  return {\n    api: api(state.api, action),\n    network: network(state.network, action),\n    domain: domain(state.domain, action),\n  };\n};\nexport default rootReducer;\n"],"names":["entity","name","data","action","state","res","json","formData","dataMap","contentType","FormData","forEach","append","key","stringify","_JSON$stringify","Error","processType","types","pathName","originalTypes","_","cloneDeep","processedTypes","map","originalType","type","meta","subsituteUrl","url","substitues","finalUrl","index","replace","setProtocol","protocol","setSwagger","swagger","setHeaders","headers","request","method","subst","dispatch","getState","get","api","paths","realPath","pathEntity","host","basePath","body","CALL_API","result","payload","network","source","domain","idsRegexResult","exec","newObjectWithIds","camelCase","BASIC","rootReducer"],"mappings":"2bAOA,SAAgBA,OAAOC,UAEnB,gBAEQ,gBACEC,KAAMD,WACL,SAACE,EAAQC,EAAOC,UAChBA,EAAIC,SAGf,WAGJ,SAAgBC,SAASC,EAASC,OAC3BD,EAAS,OAAO,QACD,wBAAhBC,EAAuC,KACrCF,EAAW,IAAIG,6BAEPF,GAASG,QAAQ,mBAAOJ,EAASK,OAAOC,EAAKL,EAAQK,MAE1DN,EACF,GAAoB,sCAAhBE,SACFK,sBAAUN,GACZ,GAAoB,qBAAhBC,SACFM,gBAAeP,SAEhB,IAAIQ,MAAM,uBAGpB,SAAgBC,YAAYC,EAAOC,OAC7BC,EAAgBC,EAAEC,UAAUJ,GAC5BK,cAEYH,EAAcI,IAAI,kBACL,iBAAhBC,GACAC,KAAMD,GAERA,MAII,iBACVL,EAAc,4BAEPD,GACLC,EAAc,GAAGO,UAGT,iBACVP,EAAc,4BAEPD,GACLC,EAAc,GAAGO,UAGT,iBACVP,EAAc,4BAEPD,GACLC,EAAc,GAAGO,QAIjBJ,EAET,SAAgBK,aAAaC,EAAKC,OAC5BC,EAAWF,sBAEHC,GAAYnB,QAAQ,SAACE,EAAKmB,KACzBD,EAASE,QAAQ,IAAMpB,EAAM,IAAKiB,EAAWjB,MAEnDkB,ECzEF,SAASG,YAAYC,eAElB,2BACGA,GAGb,SAAgBC,WAAWC,eAEjB,0BACGA,GAGb,SAAgBC,WAAWC,eAEjB,wCAEKA,IAIf,SAAgBC,QAAQrB,IAAmCD,cAAvBuB,IAAAA,OAAQvC,IAAAA,KAAMwC,IAAAA,2DACzC,WAAOC,EAAUC,4FACHvB,EAAEwB,IAAID,IAAWE,IAAIC,MAAO5B,KAChCA,EAEXuB,MACSd,aAAaoB,EAAUN,oBAK/BE,IAAWE,IAAIP,QACfU,EAAWV,kBAGF,OAAVE,IACSO,EAAW,IAAMlC,sBAAUZ,KAE/BK,SAASL,EAAMqC,EAAQ,iBAGA,wBAA5BA,EAAQ,yBACHA,EAAQ,uBACRA,EAAQ,6BAKbK,IAAWE,IAAIX,SACf,MACAS,IAAWE,IAAII,KACfN,IAAWE,IAAIK,SACfH,SACMP,UAECF,OACHa,QACCnC,YAAYC,EAAOC,cAGfwB,qBACVU,4BAAWC,iJClEH,SAASR,UAAI1C,0DAAU+B,SAAU,OAAQI,YAAepC,sBAC7DA,EAAOuB,UACR,4CACStB,GAAOmC,QAASpC,EAAOoD,QAAQhB,cACxC,uCACSnC,EAAUD,EAAOoD,aAC1B,wCACSnD,GAAO+B,SAAUhC,EAAOoD,iBAEjCnD,ECTM,SAASoD,cAAQpD,4DAAYD,uBAClC,OACc,WAAfA,EAAOuB,0BACEtB,qBAAQD,EAAOwB,KAAK8B,OAAS,gBAEvB,WAAftD,EAAOuB,0BACEtB,qBAAQD,EAAOwB,KAAK8B,OAAS,gBAEvB,WAAftD,EAAOuB,0BACEtB,qBAAQD,EAAOwB,KAAK8B,OAAS,mBAEtCrD,ECVM,SAASsD,aAAOtD,4DAAYD,eACrCwD,EAAiB,gBAAgBC,KAAKvC,EAAEwB,IAAI1C,EAAQ,sBAEhD,QACiB,MAAlBwD,MAECE,cADiBxC,EAAEyC,UAAUH,EAAe,IAAM,SAEnBxD,EAAOoD,sBAE9BnD,EAAUyD,UAEnBzD,4o4BJNI2D,OAAS,UAAW,UAAW,6OKHtCC,YAAc,eAAS5D,4DAAYD,0BAEhC2C,IAAI1C,EAAM0C,IAAK3C,WACXqD,QAAQpD,EAAMoD,QAASrD,UACxBuD,OAAOtD,EAAMsD,OAAQvD"}